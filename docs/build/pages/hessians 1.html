<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hessians · JuMPDiff</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">JuMPDiff</span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Introduction</a></li><li><a class="tocitem" href="gradients.html">Gradients</a></li><li><a class="tocitem" href="jacobians.html">Jacobians</a></li><li class="is-active"><a class="tocitem" href="hessians.html">Hessians</a><ul class="internal"><li><a class="tocitem" href="#Basics"><span>Basics</span></a></li><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li></ul></li><li><a class="tocitem" href="geometric.html">Geometric example</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="hessians.html">Hessians</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="hessians.html">Hessians</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/pages/hessians.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Hessians"><a class="docs-heading-anchor" href="#Hessians">Hessians</a><a id="Hessians-1"></a><a class="docs-heading-anchor-permalink" href="#Hessians" title="Permalink"></a></h1><h2 id="Basics"><a class="docs-heading-anchor" href="#Basics">Basics</a><a id="Basics-1"></a><a class="docs-heading-anchor-permalink" href="#Basics" title="Permalink"></a></h2><p>The Hessian of a scalar-valued differentiable function <span>$f$</span> is a square matrix of its second order partial derivatives. Hence, at a point <span>$p = (x_1,...,x_n)$</span> for <span>$f\colon \mathbb {R} ^{n}\to \mathbb {R}$</span> the Hessian <span>$\mathbf{H}_f\colon \mathbb {R} ^{n}\to \mathbb {R}^{n \times n}$</span> is defined as : </p><p class="math-container">\[\begin{aligned} 
\mathbf {H} _{f}(p) = {\begin{bmatrix}{\dfrac {\partial ^{2}f}{\partial x_{1}^{2}}(p)}&amp;{\dfrac {\partial ^{2}f}{\partial x_{1}\,\partial x_{2}}(p)}&amp;\cdots &amp;{\dfrac {\partial ^{2}f}{\partial x_{1}\,\partial x_{n}}(p)}\\[2.2ex]{\dfrac {\partial ^{2}f}{\partial x_{2}\,\partial x_{1}}(p)}&amp;{\dfrac {\partial ^{2}f}{\partial x_{2}^{2}}(p)}&amp;\cdots &amp;{\dfrac {\partial ^{2}f}{\partial x_{2}\,\partial x_{n}}(p)}\\[2.2ex]\vdots &amp;\vdots &amp;\ddots &amp;\vdots \\[2.2ex]{\dfrac {\partial ^{2}f}{\partial x_{n}\,\partial x_{1}}(p)}&amp;{\dfrac {\partial ^{2}f}{\partial x_{n}\,\partial x_{2}}(p)}&amp;\cdots &amp;{\dfrac {\partial ^{2}f}{\partial x_{n}^{2}}(p)}\end{bmatrix}}
\end{aligned}\]</p><p>JuMPDiff provides a function with different methods to compute the Hessian of the objective function of a JuMP model. </p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Different dispatches of the function <code>model_hess</code> are available to compute the Hessian of the objective function registered in the JuMP model <code>model</code>. The basic functionalities are: </p><article class="docstring"><header><a class="docstring-binding" id="JuMPDiff.model_hess" href="#JuMPDiff.model_hess"><code>JuMPDiff.model_hess</code></a> — <span class="docstring-category">Function</span></header><section><div><p>model_hess(model)</p><p>This function returns the Hessian matrix of the objective function specified in model w.r.t to all variables registered in that model. </p></div></section><section><div><p>model_hess(model, vars)</p><p>This function returns the Hessian matrix of the objective function specified in model w.r.t to the variables specified by vars. </p></div></section></article><p>Results retrieved by these methods can also be registered in the model by calling the function <code>model_hess!</code>. </p><article class="docstring"><header><a class="docstring-binding" id="JuMPDiff.model_hess!" href="#JuMPDiff.model_hess!"><code>JuMPDiff.model_hess!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>model_hess!(model;name)</p><p>This function returns the Hessian matrix of the objective function specified in the model w.r.t. all variables in that model, and additionally registers the results in the model itself.</p></div></section><section><div><p>model_hess!(model,vars;name)</p><p>This function returns the Hessian matrix of the objective fnction specified in model w.r.t. the variables specified by vars, and additionally registers the results in the model itself.</p></div></section></article><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>The following shall illustrate the use of these methods. Note that the calls of <code>model_hess</code> below are independant of each and shall merely illustrate the different available methods. For the sake of the example, let us consider an arbitray objective function with four variables: </p><pre><code class="language-julia-repl">julia&gt; model = Model();

julia&gt; @variable(model,w);

julia&gt; @variable(model,x);

julia&gt; @variable(model,y);

julia&gt; @variable(model,z);

julia&gt; @objective(model, Max, 1*w + 2*x^2 + 3*x*y + 4*y*z)
2 x² + 3 y*x + 4 z*y + w

julia&gt; model_hess(model)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  4.0  3.0  0.0
 0.0  3.0  0.0  4.0
 0.0  0.0  4.0  0.0

julia&gt; model_hess(model, [x,y])
2×2 Array{Float64,2}:
 4.0  3.0
 3.0  0.0

julia&gt; model_hess(model, [y,x])
2×2 Array{Float64,2}:
 0.0  3.0
 3.0  4.0</code></pre><p>A few things appear noteworthy in the above examples. The first is the fact that JuMP prints the terms of the objective function in a different order than specified by the user. This is due to the fact that JuMP internally represents equations as combinations of pre-defined functions and sets, defined in the abstract data structure <code>MathOptInterface</code> (see also <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>). Often times this entails equations to be rearranged.<br/>Secondly, we can see that the default variable order of the Hessian is the order in which the variables are registered in the model. In the above example this means that <span>$x_1 = w$</span>, <span>$x_2 = x$</span> etc. Similarly, if the user supplies an array of variables as second function argument, the Hessian is evaluated according to the order in that array. For example, in the second call of <code>model_hess</code> above the variable array <span>$\mathbf{x} = [x, y]$</span> is supplied, in which case the Hessian is computed as </p><p class="math-container">\[\begin{aligned} 
\mathbf {H} _{f} = {\begin{bmatrix}{\dfrac {\partial ^{2}f}{\partial x^{2}}}&amp;{\dfrac {\partial ^{2}f}{\partial x\,\partial y}} \\[2.2ex] 
{\dfrac {\partial ^{2}f}{\partial y\,\partial x}} &amp; {\dfrac {\partial ^{2}f}{\partial y^{2}}}
\end{bmatrix}}
\end{aligned}\]</p><p>while for the variable array <span>$\mathbf{x} = [y, x]$</span> supplied in the last function call the Hessian is <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup></p><p class="math-container">\[\begin{aligned} 
\mathbf {H} _{f} = {\begin{bmatrix}{\dfrac {\partial ^{2}f}{\partial y^{2}}}&amp;{\dfrac {\partial ^{2}f}{\partial y\,\partial x}} \\[2.2ex]
{\dfrac {\partial ^{2}f}{\partial x\,\partial y}} &amp; {\dfrac {\partial ^{2}f}{\partial x^{2}}}
\end{bmatrix}}
\end{aligned}\]</p><p>Another fact to note is that the resulting array is of the type <code>Float64</code>, whereas for other functions included in JuMPDiff, such as <code>model_jac</code> or <code>con_der</code>, it is <code>GenericAffExpr{Float64,VariableRef}</code> by default. This can be explained by the fact that <code>JuMPDiff</code> only handles terms up to quadratic order, for which the second derivate is a scalar in any case. Other functions included in this package however compute first derivatives and therefore require a more flexible data type. </p><p>The <code>model_hess!</code> function extends the previously described functionalities by registering the retrieved results within the JuMP model itself. </p><pre><code class="language-julia-repl">julia&gt; model_hess!(model)
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  4.0  3.0  0.0
 0.0  3.0  0.0  4.0
 0.0  0.0  4.0  0.0

julia&gt; model[:Hessian]
4×4 Array{Float64,2}:
 0.0  0.0  0.0  0.0
 0.0  4.0  3.0  0.0
 0.0  3.0  0.0  4.0
 0.0  0.0  4.0  0.0

julia&gt; model_hess!(model,[z,w],:Hessian_z_w)
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0

julia&gt; model[:Hessian_z_w]
2×2 Array{Float64,2}:
 0.0  0.0
 0.0  0.0</code></pre><p>The default name for the registered Hessian is <code>Hessian</code>. The result can then be called by querying <code>model[:Hessian]</code> (where model is the name of the JuMP model). By specifying a different name in the function arguments we can register the result under a different name, and make it callable under that name. This is what we did in the above example, since the second call of <code>model_hess!</code> would have otherwise attempted to re-register the default name <code>Hessian</code>, resulting in the following error: </p><pre><code class="language-julia-repl">julia&gt; model_hess!(model,[z,w])
ERROR: You are trying to register the name Hessian in the model, which is already occupied. If you have not specified the name Hessian, then the function you have called assumes Hessian to be the default name. To overcome this issue specify a different name in the function arguments or unregister the name Hessian from the model.
[...]</code></pre><p>A slightly different error would have been thrown if if were attempted to register the user-defined name twice:</p><pre><code class="language-julia-repl">julia&gt; model_hess!(model,[z,w], :Hessian_z_w)
ERROR: You are trying to register a name which is already occupied in the model. Choose a different one or unregister the existing.
[...]</code></pre><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><a href="https://arxiv.org/abs/2002.03447">Legat, Benoit and Dowson, Oscar and Garcia, Joaquim and Lubin, Miles     MathOptInterface: a data structure for mathematical optimization problems. <em>INFORMS Journal on Computing</em>, 2020 </a></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>Note that this only influences the entries on the main diagonal, since the mixed partial derivates are equal by Schwarz&#39;s theorem</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="jacobians.html">« Jacobians</a><a class="docs-footer-nextpage" href="geometric.html">Geometric example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 3 August 2021 21:39">Tuesday 3 August 2021</span>. Using Julia version 1.5.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
