var documenterSearchIndex = {"docs":
[{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"DocTestSetup = quote\r\n    using JuMPDiff\r\nend","category":"page"},{"location":"pages/hessians.html#Hessians","page":"Hessians","title":"Hessians","text":"","category":"section"},{"location":"pages/hessians.html#Basics","page":"Hessians","title":"Basics","text":"","category":"section"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"The Hessian of a scalar-valued differentiable function f is a square matrix of its second order partial derivatives. Hence, at a point p = (x_1x_n) for fcolon mathbb R ^nto mathbb R the Hessian mathbfH_fcolon mathbb R ^nto mathbb R^n times n is defined as : ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"beginaligned \r\nmathbf H _f(p) = beginbmatrixdfrac partial ^2fpartial x_1^2(p)dfrac partial ^2fpartial x_1partial x_2(p)cdots dfrac partial ^2fpartial x_1partial x_n(p)22exdfrac partial ^2fpartial x_2partial x_1(p)dfrac partial ^2fpartial x_2^2(p)cdots dfrac partial ^2fpartial x_2partial x_n(p)22exvdots vdots ddots vdots 22exdfrac partial ^2fpartial x_npartial x_1(p)dfrac partial ^2fpartial x_npartial x_2(p)cdots dfrac partial ^2fpartial x_n^2(p)endbmatrix\r\nendaligned","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"JuMPDiff provides a function with different methods to compute the Hessian of the objective function of a JuMP model. ","category":"page"},{"location":"pages/hessians.html#Overview","page":"Hessians","title":"Overview","text":"","category":"section"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"Different dispatches of the function model_hess are available to compute the Hessian of the objective function registered in the JuMP model model. The basic functionalities are: ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"model_hess","category":"page"},{"location":"pages/hessians.html#JuMPDiff.model_hess","page":"Hessians","title":"JuMPDiff.model_hess","text":"model_hess(model)\n\nThis function returns the Hessian matrix of the objective function specified in model w.r.t to all variables registered in that model. \n\n\n\n\n\nmodel_hess(model, vars)\n\nThis function returns the Hessian matrix of the objective function specified in model w.r.t to the variables specified by vars. \n\n\n\n\n\n","category":"function"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"Results retrieved by these methods can also be registered in the model by calling the function model_hess!. ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"model_hess!","category":"page"},{"location":"pages/hessians.html#JuMPDiff.model_hess!","page":"Hessians","title":"JuMPDiff.model_hess!","text":"model_hess!(model;name)\n\nThis function returns the Hessian matrix of the objective function specified in the model w.r.t. all variables in that model, and additionally registers the results in the model itself.\n\n\n\n\n\nmodel_hess!(model,vars;name)\n\nThis function returns the Hessian matrix of the objective fnction specified in model w.r.t. the variables specified by vars, and additionally registers the results in the model itself.\n\n\n\n\n\n","category":"function"},{"location":"pages/hessians.html#Examples","page":"Hessians","title":"Examples","text":"","category":"section"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"The following shall illustrate the use of these methods. Note that the calls of model_hess below are independant of each and shall merely illustrate the different available methods. For the sake of the example, let us consider an arbitray objective function with four variables: ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"julia> model = Model();\r\n\r\njulia> @variable(model,w);\r\n\r\njulia> @variable(model,x);\r\n\r\njulia> @variable(model,y);\r\n\r\njulia> @variable(model,z);\r\n\r\njulia> @objective(model, Max, 1*w + 2*x^2 + 3*x*y + 4*y*z)\r\n2 x² + 3 y*x + 4 z*y + w\r\n\r\njulia> model_hess(model)\r\n4×4 Array{Float64,2}:\r\n 0.0  0.0  0.0  0.0\r\n 0.0  4.0  3.0  0.0\r\n 0.0  3.0  0.0  4.0\r\n 0.0  0.0  4.0  0.0\r\n\r\njulia> model_hess(model, [x,y])\r\n2×2 Array{Float64,2}:\r\n 4.0  3.0\r\n 3.0  0.0\r\n\r\njulia> model_hess(model, [y,x])\r\n2×2 Array{Float64,2}:\r\n 0.0  3.0\r\n 3.0  4.0","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"A few things appear noteworthy in the above examples. The first is the fact that JuMP prints the terms of the objective function in a different order than specified by the user. This is due to the fact that JuMP internally represents equations as combinations of pre-defined functions and sets, defined in the abstract data structure MathOptInterface (see also [1]). Often times this entails equations to be rearranged.\nSecondly, we can see that the default variable order of the Hessian is the order in which the variables are registered in the model. In the above example this means that x_1 = w, x_2 = x etc. Similarly, if the user supplies an array of variables as second function argument, the Hessian is evaluated according to the order in that array. For example, in the second call of model_hess above the variable array mathbfx = x y is supplied, in which case the Hessian is computed as ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"beginaligned \r\nmathbf H _f = beginbmatrixdfrac partial ^2fpartial x^2dfrac partial ^2fpartial xpartial y 22ex \r\ndfrac partial ^2fpartial ypartial x  dfrac partial ^2fpartial y^2\r\nendbmatrix\r\nendaligned","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"while for the variable array mathbfx = y x supplied in the last function call the Hessian is [2]","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"beginaligned \r\nmathbf H _f = beginbmatrixdfrac partial ^2fpartial y^2dfrac partial ^2fpartial ypartial x 22ex\r\ndfrac partial ^2fpartial xpartial y  dfrac partial ^2fpartial x^2\r\nendbmatrix\r\nendaligned","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"Another fact to note is that the resulting array is of the type Float64, whereas for other functions included in JuMPDiff, such as model_jac or con_der, it is GenericAffExpr{Float64,VariableRef} by default. This can be explained by the fact that JuMPDiff only handles terms up to quadratic order, for which the second derivate is a scalar in any case. Other functions included in this package however compute first derivatives and therefore require a more flexible data type. ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"The model_hess! function extends the previously described functionalities by registering the retrieved results within the JuMP model itself. ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"julia> model_hess!(model)\r\n4×4 Array{Float64,2}:\r\n 0.0  0.0  0.0  0.0\r\n 0.0  4.0  3.0  0.0\r\n 0.0  3.0  0.0  4.0\r\n 0.0  0.0  4.0  0.0\r\n\r\njulia> model[:Hessian]\r\n4×4 Array{Float64,2}:\r\n 0.0  0.0  0.0  0.0\r\n 0.0  4.0  3.0  0.0\r\n 0.0  3.0  0.0  4.0\r\n 0.0  0.0  4.0  0.0\r\n\r\njulia> model_hess!(model,[z,w],:Hessian_z_w)\r\n2×2 Array{Float64,2}:\r\n 0.0  0.0\r\n 0.0  0.0\r\n\r\njulia> model[:Hessian_z_w]\r\n2×2 Array{Float64,2}:\r\n 0.0  0.0\r\n 0.0  0.0","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"The default name for the registered Hessian is Hessian. The result can then be called by querying model[:Hessian] (where model is the name of the JuMP model). By specifying a different name in the function arguments we can register the result under a different name, and make it callable under that name. This is what we did in the above example, since the second call of model_hess! would have otherwise attempted to re-register the default name Hessian, resulting in the following error: ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"julia> model_hess!(model,[z,w])\r\nERROR: You are trying to register the name Hessian in the model, which is already occupied. If you have not specified the name Hessian, then the function you have called assumes Hessian to be the default name. To overcome this issue specify a different name in the function arguments or unregister the name Hessian from the model.\r\n[...]","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"A slightly different error would have been thrown if if were attempted to register the user-defined name twice:","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"julia> model_hess!(model,[z,w], :Hessian_z_w)\r\nERROR: You are trying to register a name which is already occupied in the model. Choose a different one or unregister the existing.\r\n[...]","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"[1]: Legat, Benoit and Dowson, Oscar and Garcia, Joaquim and Lubin, Miles     MathOptInterface: a data structure for mathematical optimization problems. INFORMS Journal on Computing, 2020 ","category":"page"},{"location":"pages/hessians.html","page":"Hessians","title":"Hessians","text":"[2]: Note that this only influences the entries on the main diagonal, since the mixed partial derivates are equal by Schwarz's theorem","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"DocTestSetup = quote\r\n    using JuMPDiff\r\nend","category":"page"},{"location":"pages/gradients.html#Gradients","page":"Gradients","title":"Gradients","text":"","category":"section"},{"location":"pages/gradients.html#Basics","page":"Gradients","title":"Basics","text":"","category":"section"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The gradient of a scalar-valued differentiable function f is a vector nabla f whose components are the partial derivatives of f. Hence, at a point p = (x_1  x_n) for fcolon mathbb R ^nto mathbb R the gradient nabla fcolon mathbb R ^nto mathbb R^n is defined as : ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"beginaligned\r\nnabla f(p)= beginbmatrix frac partial fpartial x_1(p) vdots frac partial fpartial x_n(p)endbmatrix\r\nendaligned","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"JuMPDiff provides different functions to calculate the derivative of the objective function and constraints of a JuMP model. ","category":"page"},{"location":"pages/gradients.html#Objective-function","page":"Gradients","title":"Objective function","text":"","category":"section"},{"location":"pages/gradients.html#Overview","page":"Gradients","title":"Overview","text":"","category":"section"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"Different dispatches of the function obj_der are available to compute the gradient of the objective function registered in the JuMP-model model. The basic functionalities are the following:","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"obj_der","category":"page"},{"location":"pages/gradients.html#JuMPDiff.obj_der","page":"Gradients","title":"JuMPDiff.obj_der","text":"obj_der(model)\n\nThis function takes as input a JuMP model and returns the gradient vector of the constraint w.r.t. all variables registered in  the model. \n\n\n\n\n\nobj_der(model,vars)\n\nThis function takes as input a JuMP model and an array of variable references and returns the gradient vector of the objective function w.r.t. all variables specified in vars. \n\n\n\n\n\nobj_der(model,vals)\n\nThis function takes as input a JuMP model and an array of values and evaluates the derivative of the objective function specified at the values in vals.\n\n\n\n\n\nobj_der(model,vars,vals)\n\nThis function takes as input a JuMP model, an array of variable references and an array of values and evaluates the derivative of the objective function w.r.t. the specified variables at the specified values.\n\n\n\n\n\n","category":"function"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"Results retrieved by these methods can also be registered in the model by calling the function obj_der!. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"obj_der!","category":"page"},{"location":"pages/gradients.html#JuMPDiff.obj_der!","page":"Gradients","title":"JuMPDiff.obj_der!","text":"obj_der!(model;name)\n\nThis function takes as input a JuMP model and optionally a name. It registers the gradient of the objective function within the model under the specified name. If the user does not specify a name, the default name is obj_der. \n\n\n\n\n\nobj_der!(model,vars;name)\n\nThis function takes as input a JuMP model, an array of variable references and optionally a name. It registers the gradient of the objective function w.r.t the specified variables within the model under the specified name. If the user does not specify a name, the default name is obj_der.\n\n\n\n\n\n","category":"function"},{"location":"pages/gradients.html#Examples","page":"Gradients","title":"Examples","text":"","category":"section"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The following shall illustrate the use of these methods: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> model = Model();\r\n\r\njulia> @variable(model,x);\r\n\r\njulia> @variable(model,y);\r\n\r\njulia> @objective(model, Max, x*y - x^2 - y^2);\r\n\r\njulia> obj_der(model)\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n y - 2 x\r\n x - 2 y\r\n\r\njulia> obj_der(model,[x])\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n y - 2 x\r\n\r\njulia> obj_der(model,[2,1])\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n -3\r\n 0\r\n\r\njulia> obj_der(model,[y],[3])\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n x - 6","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"Note that the array of variable values is evaluated according to the order in which the variables are registered in the model, i.e. in the third funtion call of obj_der the value 2 is associated with the variable x and the value 1 with the variable y. This order can be queried by the user through the command index(var), in which var is the variable of which the load order is unknown. The returned index number corresponds to the belonging index in the vals array. Alternatively, the user can specify both an array of variables and values, in which case the values will be assigned to the corresponding index in the variables array (e.g. the first entry of the value array will be assigned to the first entry of the variable array). In this scenario the user can also choose to evaluate the gradient only w.r.t. certain variables. In any case, the number of values must match the number of specified variables, or if no variables are specified, to the overall amount of variables. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> obj_der(model,[2])\r\nERROR: There must be as many variables as values\r\n[...]\r\n\r\njulia> obj_der(model,[x,y],[1])\r\nERROR: There must be as many variables as values\r\n[...]","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The error in the first case results from the fact that the there are two variables registered in the model, while the user tries to only supply one value. The opposite holds true for the second scenario: Here, the user defines two variables, but only supplies one value. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The obj_der! function extends the previously described functionalities by registering the retrieved results within the JuMP model itself. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> model = Model();\r\n\r\njulia> @variable(model,x);\r\n\r\njulia> @variable(model,y);\r\n\r\njulia> @objective(model, Max, x*y - x - y);\r\n\r\njulia> obj_der!(model)\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n y - 1\r\n x - 1\r\n\r\njulia> model[:obj_der]\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n y - 1\r\n x - 1\r\n\r\njulia> obj_der!(model,[x],:examplename)\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n y - 1\r\n\r\njulia> model[:examplename]\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n y - 1","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The default name for the registered gradient is obj_der. The result can then be called by querying model[:obj_der] (where model is the name of the JuMP model). By specifying a different name in the function arguments we can register the result under a different name, and make it callable under that name. This was also necessary in the above example, since obj_der! would have tried to register the default name again, which would have resulted in an error: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> obj_der!(model,[x])\r\nERROR: You are trying to register the name obj_der in the model, which is already occupied. If you have not specified the name obj_der, then the function you have called assumes obj_der to be the default name. To overcome this issue specify a different name in the function arguments or unregister the name obj_der from the model.\r\n[...]","category":"page"},{"location":"pages/gradients.html#Constraints","page":"Gradients","title":"Constraints","text":"","category":"section"},{"location":"pages/gradients.html#Overview-2","page":"Gradients","title":"Overview","text":"","category":"section"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"Different dispatches of the function con_der are available to compute the gradient of a specified constraint registered in the JuMP-model model. The basic functionalities are the following: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"con_der","category":"page"},{"location":"pages/gradients.html#JuMPDiff.con_der","page":"Gradients","title":"JuMPDiff.con_der","text":"con_der(model,con)\n\nThis function takes as input a JuMP model and a constraint reference and returns the gradient vector of the constraint w.r.t. all variables registered in  the model. \n\n\n\n\n\ncon_der(model,con,vars)\n\nThis function takes as input a JuMP model, a constraint reference, and an array of variable references and returns the gradient vector of the constraint w.r.t. all variables specified in vars. \n\n\n\n\n\ncon_der(model,con,vals)\n\nThis function takes as input a JuMP model, a constraint reference and an array of values and evaluates the derivative of the constraint specified at the values in vals.\n\n\n\n\n\ncon_der(model,con,vars,vals)\n\nThis function takes as input a JuMP model, a constraint reference, an array of variable references and an array of values and evaluates the derivative w.r.t. the specified variables at the specified values.\n\n\n\n\n\n","category":"function"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"Results retrieved by these methods can also be registered in the model by calling the function obj_der!. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"con_der!","category":"page"},{"location":"pages/gradients.html#JuMPDiff.con_der!","page":"Gradients","title":"JuMPDiff.con_der!","text":"con_der!(model,con;name)\n\nThis function takes as input a JuMP model, a constraint reference, and optionally a name. It registers the vector of partial derivatives of the constraint within the model. If the user does not specify a value for name, the default name is con_der. Otherwise it is the user specified name.\n\n\n\n\n\ncon_der!(model,con,vars;name)\n\nThis function takes as input a JuMP model, a constraint reference, an array of variables and optionally a symbol. It registers the derivate of the specified constraint at the specified variables within the model. If the user does not specify a value for name, the default name is con_der. Otherwise it is the user specified name.\n\n\n\n\n\n","category":"function"},{"location":"pages/gradients.html#Examples-2","page":"Gradients","title":"Examples","text":"","category":"section"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The function con_der offers the same functionality as obj_der, which shall be be showcased in the following. Consider a constraint which imposes any solution to lie within the unit circle. For the sake of the example we will give this constraint the reference circle.","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> model = Model();\r\n\r\njulia> @variable(model,x);\r\n\r\njulia> @variable(model,y);\r\n\r\njulia> @constraint(model, circle, x^2 + y^2 <= 1);\r\n\r\njulia> con_der(model,circle)\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n 2 y\r\n\r\njulia> con_der(model,circle,[x])\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n\r\njulia> con_der(model,circle,[3,2])\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 6\r\n 4\r\n\r\njulia> con_der(model,circle,[y],[2])\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 4","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"Note again that the above function calls of con_der are independant of each other. Furthermore, the same remarks hold as for obj_der, namely that the values for variables are evaluated according to the order in which the variables are loaded in the model (unless specified otherwise by the user), and that the number of variable values must match the number of (specified) variables. Otherwise, an error will be thrown: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> con_der(model,circle,[1])\r\nERROR: There must be as many variables as values\r\n[...]\r\n\r\njulia> con_der(model,circle,[x,y],[2])\r\nERROR: There must be as many variables as values\r\n[...]","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The error in the first case results from the fact that the there are two variables registered in the model, while the user tries to only supply one value. The opposite holds true for the second scenario: Here, the user defines two variables, but only supplies one value. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The con_der! function extends the previously described functionalities by registering the retrieved results within the JuMP model itself. ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> con_der!(model, circle)\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n 2 y\r\n \r\njulia> model[:con_der]\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n 2 y\r\n\r\njulia> con_der!(model,circle,:circle_der)\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n 2 y\r\n\r\njulia> model[:circle_der]\r\n2-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n 2 y\r\n\r\njulia> con_der!(model,circle,[x], :circle_der_x)\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x\r\n\r\njulia> model[:circle_der_x]\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 x","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"The default name for the registered gradient is con_der. The result can then be called by querying model[:con_der] (where model is the name of the JuMP model). By specifying a different name in the function arguments we can register the result under a different name, and make it callable under that name. Note how in the above example we registered the results with three different names: First with the default name con_der, then with the name circle_der and lastly with circle_der_x. If we would have attempted to register the default name twice, an error would have been thrown: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> con_der!(model,circle,[x])\r\nERROR: You are trying to register the name con_der in the model, which is already occupied. If you have not specified the name con_der, then the function you have called assumes con_der to be the default name. To overcome this issue specify a different name in the function arguments or unregister the name con_der from the model.\r\n[...]","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"A similar message would have been thrown if it were attempted to register the same user specified name twice: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> con_der!(model,circle,[y],:circle_der)\r\nERROR: You are trying to register a name which is already occupied in the model. Choose a different one or unregister the existing.","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"As the error messages suggests it is not strictly necessary to choose a different name for every result registration, one could also unregister any pre-existig name: ","category":"page"},{"location":"pages/gradients.html","page":"Gradients","title":"Gradients","text":"julia> unregister(model,:circle_der)\r\n\r\njulia> con_der!(model,circle,[y],:circle_der)\r\n1-element Array{GenericAffExpr{Float64,VariableRef},1}:\r\n 2 y","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"DocTestSetup = quote\r\n    using JuMPDiff\r\nend","category":"page"},{"location":"pages/jacobians.html#Jacobians","page":"Jacobians","title":"Jacobians","text":"","category":"section"},{"location":"pages/jacobians.html#Basics","page":"Jacobians","title":"Basics","text":"","category":"section"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"The Jacobian of a vector-valued function f is the matrix of all its first-order partial derivatives. Hence, at a point p = (x_1x_n) for fcolon mathbb R ^nto mathbb R^m the Jacobian mathbfJcolon mathbb R ^nto mathbb R^m times n is defined as :","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"beginaligned\r\nmathbfJ(p) = beginbmatrixdfrac partial f_1partial x_1(p)cdots dfrac partial f_1partial x_n(p)vdots ddots vdots dfrac partial f_mpartial x_1(p)cdots dfrac partial f_mpartial x_n(p)endbmatrix\r\nendaligned","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"JuMPDiff provides different functions to compute the Jacobian of a JuMP model. ","category":"page"},{"location":"pages/jacobians.html#Overview","page":"Jacobians","title":"Overview","text":"","category":"section"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"Different dispatches of the function model_jac are available to compute the Jacobian of a specified JuMP model. The basic functionalities are: ","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"model_jac","category":"page"},{"location":"pages/jacobians.html#JuMPDiff.model_jac","page":"Jacobians","title":"JuMPDiff.model_jac","text":"model_jac(model)\n\nThis function takes an input a JuMP model and returns the Jacobian matrix of the model constraints w.r.t. all variables within the model. \n\n\n\n\n\nmodel_jac(model,vars)\n\nThis function takes as input a JuMP model and a set of associated variables and returns the Jacobian matrix of the model constraints  w.r.t. to the passed variables. \n\n\n\n\n\nmodel_jac(model,vals)\n\nThis function takes as input a JuMP model and an array of associated values and returns the Jacobian of the model, evaluated at the specified point. The number of specified values must match exactly the number of variables within the model. \n\n\n\n\n\nmodel_jac(model,vars,vals)\n\nThis function takes as input a JuMP model and an array of associated variables and returns the Jacobian matrix of the model constraints  w.r.t. the passed variables, evaluated at the point specified by vals. \n\n\n\n\n\nmodel_jac(model,vals)\n\nThis function takes as input a JuMP model and an array of associated values and returns the Jacobian of the model, evaluated at the specified point. The number of specified values must match exactly the number of variables within the model. \n\n\n\n\n\nmodel_jac(model,vars,vals)\n\nThis function takes as input a JuMP model and a set of associated variables and returns the Jacobian matrix of the model constraints  w.r.t. to the passed variables, evaluated at the point specified by vals. \n\n\n\n\n\n","category":"function"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"Results retrieved by these methods can also be registered in the model by calling the function model_jac!`.","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"model_jac!","category":"page"},{"location":"pages/jacobians.html#JuMPDiff.model_jac!","page":"Jacobians","title":"JuMPDiff.model_jac!","text":"model_jac!(model)\n\nThis function takes as input a JuMP model and computes its Jacobian. The Jacobian is registered as expression within the model with the default name  \"Jacobian\".\n\n\n\n\n\nmodel_jac!(model,vars)\n\nThis function takes as input a JuMP model and an array of associated variables and computes the Jacobian w.r.t. the specified variables. The Jacobian is registered as expression within the model with the default name \"Jacobian\". \n\n\n\n\n\nmodel_jac!(model)\n\nThis function takes as input a JuMP model and computes its Jacobian. The Jaocbian is registered as expression within the model with the default name  \"Jacobian\".\n\n\n\n\n\nmodel_jac!(model,vars)\n\nThis function takes as input a JuMP model and an array of associated variables and computes the Jacobian w.r.t. the specified variables. The Jacobian is registered as expression within the model with the default name \"Jacobian\". \n\n\n\n\n\n","category":"function"},{"location":"pages/jacobians.html#Examples","page":"Jacobians","title":"Examples","text":"","category":"section"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"The following shall illustrate the use of these methods. Note that the calls of model_jac below are independant of each and shall merely illustrate the different available methods. ","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"julia> model = Model();\r\n\r\njulia> @variable(model,x); \r\n\r\njulia> @variable(model,y);\r\n\r\njulia> @variable(model,z); \r\n\r\njulia> @constraint(model, 5*x^2 + 3*y^2 == 10);\r\n\r\njulia> @constraint(model, x*z == 0); \r\n\r\njulia> @constraint(model, y >= 0);\r\n\r\njulia> @objective(model, Max, x^2 - y*x);\r\n\r\njulia> model_jac(model)\r\n4×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 2 x - y  -x   0\r\n 0        1    0\r\n 10 x     6 y  0\r\n z        0    x\r\n\r\njulia> model_jac(model,[x,y])\r\n4×2 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 2 x - y  -x\r\n 0        1\r\n 10 x     6 y\r\n z        0\r\n\r\njulia> model_jac(model,[1,1,1])\r\n4×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 1   -1  0\r\n 0   1   0\r\n 10  6   0\r\n 1   0   1\r\n \r\njulia> model_jac(model,[y,x], [1,1])\r\n4×2 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n -1  1\r\n 1   0\r\n 6   10\r\n 0   z","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"Note that the order in which the partial derivatives are evaluated is the order in which the corresponding variables are loaded into the model, i.e. by the default the first column of the Jacobian will correspond to the variable x, the second to y and the third to z. The user may revert this order by specifying an array of variables as done in the last function call above. This way it is also possible to only compute the Jacobian w.r.t. certain variables (y and x in the above example). Also note that the number of specified values must always equal the number of specified variables (which is the total number of variables in case no variable array is specified, as done in the third function call). The function will otherwise throw an error: ","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"julia> model_jac(model,[1,1])\r\nERROR: There must be as many variables as values\r\n[...]\r\n\r\njulia> model_jac(model,[x,y,z],[2,2])\r\nERROR: There must be as many variables as values\r\n[...]","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"Another thing to note is the order in which the functions in model are evaluated in the Jacobian. From the above example it becomes clear that this order does not equal the order in which the equations were loaded in the model. Rather, the equations are sorted: The first evaluated equation is always the objective function, followed by the constraints. The constraints are evaluated according to the type they represent in the MOI data structure [1]. Indicatively, this means that scalar constraints are evaluated first, and scalar EqualTo constraints are evaluted before GreaterThan constraints. This is followed by the evaluation of the quadratic constraints, where again the EqualTo constraints precede the GreaterThan constraints. Within a single constraint type the evaluation order is the order in which the constraints were loaded to the model. The different types of constraint registered in a JuMP model can always be queried via MOI.get[2]","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"julia> MOI.get(model,MOI.ListOfConstraints())\r\n2-element Array{Tuple{DataType,DataType},1}:\r\n (MathOptInterface.ScalarAffineFunction{Float64}, MathOptInterface.GreaterThan{Float64})\r\n (MathOptInterface.ScalarQuadraticFunction{Float64}, MathOptInterface.EqualTo{Float64})","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"The model_jac! function extends the previously described functionalities by registering the retrieved results within the JuMP model itself. ","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"julia> model_jac!(model)\r\n4×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 2 x - y  -x   0\r\n 0        1    0\r\n 10 x     6 y  0\r\n z        0    x\r\n\r\njulia> model[:Jacobian]\r\n4×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 2 x - y  -x   0\r\n 0        1    0\r\n 10 x     6 y  0\r\n z        0    x\r\n\r\njulia> model_jac!(model,[x,y],:Jacobian_x_y)\r\n4×2 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 2 x - y  -x\r\n 0        1\r\n 10 x     6 y\r\n z        0\r\n\r\njulia> model[:Jacobian_x_y]\r\n4×2 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 2 x - y  -x\r\n 0        1\r\n 10 x     6 y\r\n z        0","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"The default name for the registered Jacobian is Jacobian. The result can then be called by querying model[:Jacobian] (where model is the name of the JuMP model). By specifying a different name in the function arguments we can register the result under a different name, and make it callable under that name. This is what we did in the above example, since the second call of model_jac! would have otherwise attempted to re-register the default name Jacobian, resulting in the following error: ","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"julia> model_jac!(model,[x,y])\r\nERROR: You are trying to register the name Jacobian in the model, which is already occupied. If you have not specified the name Jacobian, then the function you have called assumes Jacobian to be the default name. To overcome this issue specify a different name in the function arguments or unregister the name Jacobian from the model.\r\n[...]","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"A slightly different error would have been thrown if it were attempted to register the user-defined name twice:","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"julia> model_jac!(model,[x,y], :Jacobian_x_y)\r\nERROR: You are trying to register a name which is already occupied in the model. Choose a different one or unregister the existing.\r\n[...]","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"[1]: Legat, Benoit and Dowson, Oscar and Garcia, Joaquim and Lubin, Miles     MathOptInterface: a data structure for mathematical optimization problems. INFORMS Journal on Computing, 2020 ","category":"page"},{"location":"pages/jacobians.html","page":"Jacobians","title":"Jacobians","text":"[2]: Note that bilinear terms are of quadratic type in JuMP","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"DocTestSetup = quote\r\n    using JuMPDiff, Ipopt\r\nend","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"using Plots; pyplot()\r\nPlots.reset_defaults()","category":"page"},{"location":"pages/geometric.html#Geometric-example","page":"Geometric example","title":"Geometric example","text":"","category":"section"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"Let us consider the function f(xy) = (2x^2 +3y^2) +4xy which we wish to minimize, with all candidate solutions required to lie on the unit circle g(xy) = x^2 + y^2 - 1 = 0. We plot the objective function and the constraint for a better understanding of what we are working with. ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"using Plots\r\nx = -2:0.1:2;\r\ny = -2:0.1:2;\r\nf(x,y) = 2*x.^2 + 3*y.^2 + 4*x.*y    #Our objective function\r\nsurface(x,y,f);                      #Surface plot of objective function\r\nx = -1:0.1:1\r\ny = sqrt.(1 .- x.^2)\r\nplot!(x,y,f(x,y),c=:cyan,legend = false)\r\nplot!(x,-y,f(x,-y),c=:cyan, legend = false)\r\n","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"Our next step is to analytically find and analyze the solutions of this problem with the aid of JuMPDiff functions. Afterwards, we will compare these results to ones obtained numerically with the Ipopt solver. ","category":"page"},{"location":"pages/geometric.html#Analytical-solution","page":"Geometric example","title":"Analytical solution","text":"","category":"section"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"For the analytical solution of this problem we will use the method of Lagrange multipliers. ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"julia> using JuMPDiff, Ipopt\r\n\r\njulia> model = Model(Ipopt.Optimizer); \r\n\r\njulia> @variable(model,x, start = 1);\r\n\r\njulia> @variable(model,y, start = 1);\r\n\r\njulia> @variable(model, λ); #Lagrange multiplier\r\n\r\njulia> @constraint(model,circle, x^2 + y^2 - 1 == 0);\r\n\r\njulia> @expression(model,g,x^2 + y^2 -1); #Left hand side of the constraint\r\n\r\njulia> @objective(model, Min, (2x^2 +3y^2) +4x*y); ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"The Lagrangian of this problem is defined as ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"beginaligned\r\nmathcalL(xylambda) = f(xy) - lambda g(xy)\r\nendaligned","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"and we seek to find x, y and lambda s.t. ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"beginaligned\r\nnabla_xylambda mathcalL(xylambda) = nabla_xyf(xy) - lambda nabla_xy g(xy) = 0\r\nendaligned ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"The partial derivatives of mathcalL with respect to x and y can be easily constructed with the con_der and obj_der functions, the partial derivative w.r.t. lambda is merely g itself. ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"julia> ∇L = obj_der(model,[x,y]) - λ*con_der(model,circle,[x,y])\r\n2-element Array{GenericQuadExpr{Float64,VariableRef},1}:\r\n -2 λ*x + 4 x + 4 y\r\n -2 λ*y + 6 y + 4 x\r\n\r\njulia> push!(∇L, g)\r\n3-element Array{GenericQuadExpr{Float64,VariableRef},1}:\r\n -2 λ*x + 4 x + 4 y\r\n -2 λ*y + 6 y + 4 x\r\n x² + y² - 1","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"note: Note\nIt is also possible to first construct the Lagrangian and then only use obj_der to compute its gradient. In the above example we were however required to assemble the gradient from the derivatives of the constituting expressions, since the constraint is quadratic and can not be multiplied with λ without making it a NLexpression.","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"For the sake of brevity the analytical solution procedure for solving mathcalL = 0 shall rather be briefly explained than shown in great detail. One of the ways of solving the set of equations is to first eliminate λ from the first two equations. By then isolating x or y in the third equation and inserting the resulting expression in equations one and two we can find numerical values for either one of these variables. Doing so we find","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"beginaligned\r\ny_1 = x_1 = pm sqrtfrac12 - frac12 sqrt17 approx pm 061541 \r\ny_2 = x_2 = pm sqrtfrac12 + frac12 sqrt17 approx pm  078821 \r\nendaligned","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"where all combinations of x and y with different indices are valid critical points. To learn more about the nature of these critical points we can evaluate the bordered Hessian barH, which for the current case is defined as ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"beginaligned\r\nbarH(xy) =beginbmatrix0frac  partial gpartial xfrac  partial gpartial y15exfrac  partial gpartial xfrac  partial ^2mathcalLpartial x^2frac  partial ^2mathcalLpartial xpartial y15exfrac  partial gpartial yfrac  partial ^2mathcalLpartial ypartial xfrac  partial ^2mathcalLpartial y^2endbmatrix\r\nendaligned","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"We can easily construct the bordered Hessian by using the model_hess function and the con_der function. In doing so we can also make use of the fact that JuMPDiff offers the possibility to have derivatives evaluated at specified points. ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"julia> H = Array{GenericAffExpr{Float64,VariableRef}}(undef,(3,3)); #Initialize array\r\n\r\njulia> H[1,1] = 0;\r\n\r\njulia> H[1,2:3] = con_der(model,circle,[x,y],[-0.7882, 0.6125]); #Evaluated at given point\r\n\r\njulia> H                            \r\n3×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n    0       -1.5764     1.225\r\n #undef  #undef      #undef\r\n #undef  #undef      #undef\r\n\r\njulia> H[2:3,1] = con_der(model,circle,[x,y],[-0.7882, 0.6125]);\r\n\r\njulia> H \r\n3×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 0           -1.5764     1.225\r\n -1.5764  #undef      #undef\r\n 1.225    #undef      #undef\r\n\r\njulia> H[2:3,2:3] = model_hess(model,[x,y]);\r\n\r\njulia> H\r\n3×3 Array{GenericAffExpr{Float64,VariableRef},2}:\r\n 0        -1.5764  1.225\r\n -1.5764  4        4\r\n 1.225    4        6","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"The determinant of barH(-0788206125) turns out to be negative, and we can therefore conclude that this point is a local minimizer. Taking into account the curvature of the feasible set in the above figure we can even be certain that this is actually the global minimizer of our problem. ","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"note: Note\nIn fact, the point (0.7882,-0.6125) equally minimizes our problem due to its symmetry.","category":"page"},{"location":"pages/geometric.html#Numerical-Solution","page":"Geometric example","title":"Numerical Solution","text":"","category":"section"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"Clearly, the above example was artificial since we can find the minimum way easier numerically.","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"julia> set_silent(model) \r\ntrue \r\n\r\njulia> optimize!(model);\r\n\r\njulia> value(x)\r\n0.788205437944948\r\n\r\njulia> value(y)\r\n-0.6154122094937813","category":"page"},{"location":"pages/geometric.html","page":"Geometric example","title":"Geometric example","text":"The solver finds one of the minima which we have previously identified analytically. To find the second minima, we would have to supply a different initial guess to Ipopt.","category":"page"},{"location":"index.html#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"So far, this documentation is empty.","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"model_pdv(model::Model, vars::Array{JuMP.VariableRef})","category":"page"}]
}
